'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var uuid = require('uuid');

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var AccessedStudyguideV1 = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessedStudyguideV1ToJSON = exports.AccessedStudyguideV1FromJSONTyped = exports.AccessedStudyguideV1FromJSON = exports.AccessedStudyguideV1TypeEnum = void 0;
/**
* @export
* @enum {string}
*/
var AccessedStudyguideV1TypeEnum;
(function (AccessedStudyguideV1TypeEnum) {
    AccessedStudyguideV1TypeEnum["OrgOpenstaxEcAccessedStudyguideV1"] = "org.openstax.ec.accessed_studyguide_v1";
})(AccessedStudyguideV1TypeEnum = exports.AccessedStudyguideV1TypeEnum || (exports.AccessedStudyguideV1TypeEnum = {}));
function AccessedStudyguideV1FromJSON(json) {
    return AccessedStudyguideV1FromJSONTyped(json);
}
exports.AccessedStudyguideV1FromJSON = AccessedStudyguideV1FromJSON;
function AccessedStudyguideV1FromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'clientClockOccurredAt': (new Date(json['client_clock_occurred_at'])),
        'clientClockSentAt': (new Date(json['client_clock_sent_at'])),
        'type': json['type'],
        'sourceUri': json['source_uri'],
        'sessionUuid': json['session_uuid'],
        'sessionOrder': json['session_order'],
        'pageId': json['page_id'],
        'bookId': json['book_id'],
    };
}
exports.AccessedStudyguideV1FromJSONTyped = AccessedStudyguideV1FromJSONTyped;
function AccessedStudyguideV1ToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'client_clock_occurred_at': (value.clientClockOccurredAt.toISOString()),
        'client_clock_sent_at': (value.clientClockSentAt.toISOString()),
        'type': value.type,
        'source_uri': value.sourceUri,
        'session_uuid': value.sessionUuid,
        'session_order': value.sessionOrder,
        'page_id': value.pageId,
        'book_id': value.bookId,
    };
}
exports.AccessedStudyguideV1ToJSON = AccessedStudyguideV1ToJSON;
});

unwrapExports(AccessedStudyguideV1);
var AccessedStudyguideV1_1 = AccessedStudyguideV1.AccessedStudyguideV1ToJSON;
var AccessedStudyguideV1_2 = AccessedStudyguideV1.AccessedStudyguideV1FromJSONTyped;
var AccessedStudyguideV1_3 = AccessedStudyguideV1.AccessedStudyguideV1FromJSON;
var AccessedStudyguideV1_4 = AccessedStudyguideV1.AccessedStudyguideV1TypeEnum;

var ChangedStateV1 = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangedStateV1ToJSON = exports.ChangedStateV1FromJSONTyped = exports.ChangedStateV1FromJSON = exports.ChangedStateV1TypeEnum = void 0;
/**
* @export
* @enum {string}
*/
var ChangedStateV1TypeEnum;
(function (ChangedStateV1TypeEnum) {
    ChangedStateV1TypeEnum["OrgOpenstaxEcChangedStateV1"] = "org.openstax.ec.changed_state_v1";
})(ChangedStateV1TypeEnum = exports.ChangedStateV1TypeEnum || (exports.ChangedStateV1TypeEnum = {}));
function ChangedStateV1FromJSON(json) {
    return ChangedStateV1FromJSONTyped(json);
}
exports.ChangedStateV1FromJSON = ChangedStateV1FromJSON;
function ChangedStateV1FromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'clientClockOccurredAt': (new Date(json['client_clock_occurred_at'])),
        'clientClockSentAt': (new Date(json['client_clock_sent_at'])),
        'type': json['type'],
        'sourceUri': json['source_uri'],
        'sessionUuid': json['session_uuid'],
        'sessionOrder': json['session_order'],
        'stateType': json['state_type'],
        'current': json['current'],
        'previous': json['previous'],
    };
}
exports.ChangedStateV1FromJSONTyped = ChangedStateV1FromJSONTyped;
function ChangedStateV1ToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'client_clock_occurred_at': (value.clientClockOccurredAt.toISOString()),
        'client_clock_sent_at': (value.clientClockSentAt.toISOString()),
        'type': value.type,
        'source_uri': value.sourceUri,
        'session_uuid': value.sessionUuid,
        'session_order': value.sessionOrder,
        'state_type': value.stateType,
        'current': value.current,
        'previous': value.previous,
    };
}
exports.ChangedStateV1ToJSON = ChangedStateV1ToJSON;
});

unwrapExports(ChangedStateV1);
var ChangedStateV1_1 = ChangedStateV1.ChangedStateV1ToJSON;
var ChangedStateV1_2 = ChangedStateV1.ChangedStateV1FromJSONTyped;
var ChangedStateV1_3 = ChangedStateV1.ChangedStateV1FromJSON;
var ChangedStateV1_4 = ChangedStateV1.ChangedStateV1TypeEnum;

var CreatedHighlightV1 = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreatedHighlightV1ToJSON = exports.CreatedHighlightV1FromJSONTyped = exports.CreatedHighlightV1FromJSON = exports.CreatedHighlightV1TypeEnum = void 0;
/**
* @export
* @enum {string}
*/
var CreatedHighlightV1TypeEnum;
(function (CreatedHighlightV1TypeEnum) {
    CreatedHighlightV1TypeEnum["OrgOpenstaxEcCreatedHighlightV1"] = "org.openstax.ec.created_highlight_v1";
})(CreatedHighlightV1TypeEnum = exports.CreatedHighlightV1TypeEnum || (exports.CreatedHighlightV1TypeEnum = {}));
function CreatedHighlightV1FromJSON(json) {
    return CreatedHighlightV1FromJSONTyped(json);
}
exports.CreatedHighlightV1FromJSON = CreatedHighlightV1FromJSON;
function CreatedHighlightV1FromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'clientClockOccurredAt': (new Date(json['client_clock_occurred_at'])),
        'clientClockSentAt': (new Date(json['client_clock_sent_at'])),
        'type': json['type'],
        'sourceUri': json['source_uri'],
        'sessionUuid': json['session_uuid'],
        'sessionOrder': json['session_order'],
        'highlightId': json['highlight_id'],
        'sourceType': json['source_type'],
        'sourceId': json['source_id'],
        'sourceMetadata': json['source_metadata'],
        'annotation': json['annotation'],
        'anchor': json['anchor'],
        'color': json['color'],
        'locationStrategies': json['location_strategies'],
        'scopeId': json['scope_id'],
    };
}
exports.CreatedHighlightV1FromJSONTyped = CreatedHighlightV1FromJSONTyped;
function CreatedHighlightV1ToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'client_clock_occurred_at': (value.clientClockOccurredAt.toISOString()),
        'client_clock_sent_at': (value.clientClockSentAt.toISOString()),
        'type': value.type,
        'source_uri': value.sourceUri,
        'session_uuid': value.sessionUuid,
        'session_order': value.sessionOrder,
        'highlight_id': value.highlightId,
        'source_type': value.sourceType,
        'source_id': value.sourceId,
        'source_metadata': value.sourceMetadata,
        'annotation': value.annotation,
        'anchor': value.anchor,
        'color': value.color,
        'location_strategies': value.locationStrategies,
        'scope_id': value.scopeId,
    };
}
exports.CreatedHighlightV1ToJSON = CreatedHighlightV1ToJSON;
});

unwrapExports(CreatedHighlightV1);
var CreatedHighlightV1_1 = CreatedHighlightV1.CreatedHighlightV1ToJSON;
var CreatedHighlightV1_2 = CreatedHighlightV1.CreatedHighlightV1FromJSONTyped;
var CreatedHighlightV1_3 = CreatedHighlightV1.CreatedHighlightV1FromJSON;
var CreatedHighlightV1_4 = CreatedHighlightV1.CreatedHighlightV1TypeEnum;

var runtime = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.Configuration = exports.COLLECTION_FORMATS = exports.RequiredError = exports.BaseAPI = exports.BASE_PATH = void 0;
exports.BASE_PATH = "https://api-state-change.ec.sandbox.openstax.org/api/v0".replace(/\/+$/, "");
const isBlob = (value) => typeof Blob !== 'undefined' && value instanceof Blob;
/**
 * This is the base class for all generated API classes.
 */
class BaseAPI {
    constructor(configuration = new Configuration()) {
        this.configuration = configuration;
        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {
            let fetchParams = { url, init };
            for (const middleware of this.middleware) {
                if (middleware.pre) {
                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;
                }
            }
            let response = yield this.configuration.fetchApi(fetchParams.url, fetchParams.init);
            for (const middleware of this.middleware) {
                if (middleware.post) {
                    response = (yield middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone(),
                    })) || response;
                }
            }
            return response;
        });
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware(...middlewares);
    }
    request(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url, init } = this.createFetchParams(context);
            const response = yield this.fetchApi(url, init);
            if (response.status >= 200 && response.status < 300) {
                return response;
            }
            throw response;
        });
    }
    createFetchParams(context) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const body = ((typeof FormData !== "undefined" && context.body instanceof FormData) || context.body instanceof URLSearchParams || isBlob(context.body))
            ? context.body
            : JSON.stringify(context.body);
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        const init = {
            method: context.method,
            headers: headers,
            body,
            credentials: this.configuration.credentials
        };
        return { url, init };
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
exports.BaseAPI = BaseAPI;
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
class Configuration {
    constructor(configuration = {}) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi || window.fetch.bind(window);
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
exports.Configuration = Configuration;
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
exports.exists = exists;
function querystring(params, prefix = '') {
    return Object.keys(params)
        .map((key) => {
        const fullKey = prefix + (prefix.length ? `[${key}]` : key);
        const value = params[key];
        if (value instanceof Array) {
            const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
                .join(`&${encodeURIComponent(fullKey)}=`);
            return `${encodeURIComponent(fullKey)}=${multiValue}`;
        }
        if (value instanceof Date) {
            return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
        }
        if (value instanceof Object) {
            return querystring(value, fullKey);
        }
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
    })
        .filter(part => part.length > 0)
        .join('&');
}
exports.querystring = querystring;
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: fn(data[key]) })), {});
}
exports.mapValues = mapValues;
function canConsumeForm(consumes) {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
exports.canConsumeForm = canConsumeForm;
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue) => jsonValue) {
        this.raw = raw;
        this.transformer = transformer;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.transformer(yield this.raw.json());
        });
    }
}
exports.JSONApiResponse = JSONApiResponse;
class VoidApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
}
exports.VoidApiResponse = VoidApiResponse;
class BlobApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.raw.blob();
        });
    }
    ;
}
exports.BlobApiResponse = BlobApiResponse;
class TextApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.raw.text();
        });
    }
    ;
}
exports.TextApiResponse = TextApiResponse;
});

unwrapExports(runtime);
var runtime_1 = runtime.TextApiResponse;
var runtime_2 = runtime.BlobApiResponse;
var runtime_3 = runtime.VoidApiResponse;
var runtime_4 = runtime.JSONApiResponse;
var runtime_5 = runtime.canConsumeForm;
var runtime_6 = runtime.mapValues;
var runtime_7 = runtime.querystring;
var runtime_8 = runtime.exists;
var runtime_9 = runtime.Configuration;
var runtime_10 = runtime.COLLECTION_FORMATS;
var runtime_11 = runtime.RequiredError;
var runtime_12 = runtime.BaseAPI;
var runtime_13 = runtime.BASE_PATH;

var InteractedElementV1 = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractedElementV1ToJSON = exports.InteractedElementV1FromJSONTyped = exports.InteractedElementV1FromJSON = exports.InteractedElementV1TypeEnum = void 0;

/**
* @export
* @enum {string}
*/
var InteractedElementV1TypeEnum;
(function (InteractedElementV1TypeEnum) {
    InteractedElementV1TypeEnum["OrgOpenstaxEcInteractedElementV1"] = "org.openstax.ec.interacted_element_v1";
})(InteractedElementV1TypeEnum = exports.InteractedElementV1TypeEnum || (exports.InteractedElementV1TypeEnum = {}));
function InteractedElementV1FromJSON(json) {
    return InteractedElementV1FromJSONTyped(json);
}
exports.InteractedElementV1FromJSON = InteractedElementV1FromJSON;
function InteractedElementV1FromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'clientClockOccurredAt': (new Date(json['client_clock_occurred_at'])),
        'clientClockSentAt': (new Date(json['client_clock_sent_at'])),
        'type': json['type'],
        'sourceUri': json['source_uri'],
        'sessionUuid': json['session_uuid'],
        'sessionOrder': json['session_order'],
        'targetId': json['target_id'],
        'targetType': json['target_type'],
        'targetAttributes': json['target_attributes'],
        'targetStateChange': !runtime.exists(json, 'target_state_change') ? undefined : json['target_state_change'],
        'contextId': json['context_id'],
        'contextType': json['context_type'],
        'contextAttributes': json['context_attributes'],
        'contextRegion': !runtime.exists(json, 'context_region') ? undefined : json['context_region'],
    };
}
exports.InteractedElementV1FromJSONTyped = InteractedElementV1FromJSONTyped;
function InteractedElementV1ToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'client_clock_occurred_at': (value.clientClockOccurredAt.toISOString()),
        'client_clock_sent_at': (value.clientClockSentAt.toISOString()),
        'type': value.type,
        'source_uri': value.sourceUri,
        'session_uuid': value.sessionUuid,
        'session_order': value.sessionOrder,
        'target_id': value.targetId,
        'target_type': value.targetType,
        'target_attributes': value.targetAttributes,
        'target_state_change': value.targetStateChange,
        'context_id': value.contextId,
        'context_type': value.contextType,
        'context_attributes': value.contextAttributes,
        'context_region': value.contextRegion,
    };
}
exports.InteractedElementV1ToJSON = InteractedElementV1ToJSON;
});

unwrapExports(InteractedElementV1);
var InteractedElementV1_1 = InteractedElementV1.InteractedElementV1ToJSON;
var InteractedElementV1_2 = InteractedElementV1.InteractedElementV1FromJSONTyped;
var InteractedElementV1_3 = InteractedElementV1.InteractedElementV1FromJSON;
var InteractedElementV1_4 = InteractedElementV1.InteractedElementV1TypeEnum;

var NudgedV1 = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NudgedV1ToJSON = exports.NudgedV1FromJSONTyped = exports.NudgedV1FromJSON = exports.NudgedV1TypeEnum = void 0;
/**
* @export
* @enum {string}
*/
var NudgedV1TypeEnum;
(function (NudgedV1TypeEnum) {
    NudgedV1TypeEnum["OrgOpenstaxEcNudgedV1"] = "org.openstax.ec.nudged_v1";
})(NudgedV1TypeEnum = exports.NudgedV1TypeEnum || (exports.NudgedV1TypeEnum = {}));
function NudgedV1FromJSON(json) {
    return NudgedV1FromJSONTyped(json);
}
exports.NudgedV1FromJSON = NudgedV1FromJSON;
function NudgedV1FromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'clientClockOccurredAt': (new Date(json['client_clock_occurred_at'])),
        'clientClockSentAt': (new Date(json['client_clock_sent_at'])),
        'type': json['type'],
        'sourceUri': json['source_uri'],
        'sessionUuid': json['session_uuid'],
        'sessionOrder': json['session_order'],
        'app': json['app'],
        'target': json['target'],
        'context': json['context'],
        'flavor': json['flavor'],
        'medium': json['medium'],
    };
}
exports.NudgedV1FromJSONTyped = NudgedV1FromJSONTyped;
function NudgedV1ToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'client_clock_occurred_at': (value.clientClockOccurredAt.toISOString()),
        'client_clock_sent_at': (value.clientClockSentAt.toISOString()),
        'type': value.type,
        'source_uri': value.sourceUri,
        'session_uuid': value.sessionUuid,
        'session_order': value.sessionOrder,
        'app': value.app,
        'target': value.target,
        'context': value.context,
        'flavor': value.flavor,
        'medium': value.medium,
    };
}
exports.NudgedV1ToJSON = NudgedV1ToJSON;
});

unwrapExports(NudgedV1);
var NudgedV1_1 = NudgedV1.NudgedV1ToJSON;
var NudgedV1_2 = NudgedV1.NudgedV1FromJSONTyped;
var NudgedV1_3 = NudgedV1.NudgedV1FromJSON;
var NudgedV1_4 = NudgedV1.NudgedV1TypeEnum;

var StartedSessionV1 = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartedSessionV1ToJSON = exports.StartedSessionV1FromJSONTyped = exports.StartedSessionV1FromJSON = exports.StartedSessionV1ServiceWorkerEnum = exports.StartedSessionV1TypeEnum = void 0;

/**
* @export
* @enum {string}
*/
var StartedSessionV1TypeEnum;
(function (StartedSessionV1TypeEnum) {
    StartedSessionV1TypeEnum["OrgOpenstaxEcStartedSessionV1"] = "org.openstax.ec.started_session_v1";
})(StartedSessionV1TypeEnum = exports.StartedSessionV1TypeEnum || (exports.StartedSessionV1TypeEnum = {})); /**
* @export
* @enum {string}
*/
var StartedSessionV1ServiceWorkerEnum;
(function (StartedSessionV1ServiceWorkerEnum) {
    StartedSessionV1ServiceWorkerEnum["Unsupported"] = "unsupported";
    StartedSessionV1ServiceWorkerEnum["Inactive"] = "inactive";
    StartedSessionV1ServiceWorkerEnum["Active"] = "active";
})(StartedSessionV1ServiceWorkerEnum = exports.StartedSessionV1ServiceWorkerEnum || (exports.StartedSessionV1ServiceWorkerEnum = {}));
function StartedSessionV1FromJSON(json) {
    return StartedSessionV1FromJSONTyped(json);
}
exports.StartedSessionV1FromJSON = StartedSessionV1FromJSON;
function StartedSessionV1FromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'clientClockOccurredAt': (new Date(json['client_clock_occurred_at'])),
        'clientClockSentAt': (new Date(json['client_clock_sent_at'])),
        'type': json['type'],
        'sourceUri': json['source_uri'],
        'referrer': json['referrer'],
        'sessionUuid': json['session_uuid'],
        'releaseId': !runtime.exists(json, 'release_id') ? undefined : json['release_id'],
        'serviceWorker': !runtime.exists(json, 'service_worker') ? undefined : json['service_worker'],
    };
}
exports.StartedSessionV1FromJSONTyped = StartedSessionV1FromJSONTyped;
function StartedSessionV1ToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'client_clock_occurred_at': (value.clientClockOccurredAt.toISOString()),
        'client_clock_sent_at': (value.clientClockSentAt.toISOString()),
        'type': value.type,
        'source_uri': value.sourceUri,
        'referrer': value.referrer,
        'session_uuid': value.sessionUuid,
        'release_id': value.releaseId,
        'service_worker': value.serviceWorker,
    };
}
exports.StartedSessionV1ToJSON = StartedSessionV1ToJSON;
});

unwrapExports(StartedSessionV1);
var StartedSessionV1_1 = StartedSessionV1.StartedSessionV1ToJSON;
var StartedSessionV1_2 = StartedSessionV1.StartedSessionV1FromJSONTyped;
var StartedSessionV1_3 = StartedSessionV1.StartedSessionV1FromJSON;
var StartedSessionV1_4 = StartedSessionV1.StartedSessionV1ServiceWorkerEnum;
var StartedSessionV1_5 = StartedSessionV1.StartedSessionV1TypeEnum;

const combineProviders = (p1, p2) => (input) => {
    const initializedP1 = p1(input);
    const initializedP2 = p2(input);
    return () => (Object.assign(Object.assign({}, initializedP1()), initializedP2()));
};
const combineManyProviders = (first, ...providers) => {
    const [second, ...rest] = providers;
    if (!second) {
        return first;
    }
    return combineProviders(first, combineManyProviders(second, ...rest));
};

const createEvent = (formatter, ...providers) => {
    const [first, ...rest] = providers;
    if (!first) {
        return (input) => () => formatter(input);
    }
    const provider = combineManyProviders(first, ...rest);
    const factory = (...args) => {
        const initializedProvider = provider(args[0]);
        return () => formatter(Object.assign(Object.assign({}, initializedProvider()), args[0]));
    };
    return factory;
};

const clientClockProvider = () => {
    const clientClockOccurredAt = new Date();
    return () => ({
        clientClockOccurredAt,
        clientClockSentAt: new Date(),
    });
};
const serviceWorkerStateProvider = (windowInput) => {
    const win = windowInput || (typeof window === 'undefined' ? undefined : window);
    return () => () => {
        if (!win || !('navigator' in win) || !('serviceWorker' in win.navigator)) {
            return { serviceWorker: 'unsupported' };
        }
        return {
            serviceWorker: win.navigator.serviceWorker.controller
                && win.navigator.serviceWorker.controller.state === 'activated'
                ? 'active'
                : 'inactive'
        };
    };
};
const createSessionProvider = (sessionUuid = uuid.v4(), orderState = 0) => () => {
    const sessionOrder = orderState++;
    return () => ({
        sessionUuid,
        sessionOrder,
    });
};
const typeProvider = (type) => () => () => ({ type });
const referrerProvider = (documentInput) => {
    const doc = documentInput || (typeof document === 'undefined' ? undefined : document);
    return (params) => () => {
        var _a;
        return ({
            referrer: (_a = (params && params.referrer)) !== null && _a !== void 0 ? _a : (doc ? doc.referrer : ''),
        });
    };
};
const sourceUriProvider = (windowInput) => {
    const win = windowInput || (typeof window === 'undefined' ? undefined : window);
    return (params) => () => {
        var _a;
        return ({
            sourceUri: (_a = (params && params.sourceUri)) !== null && _a !== void 0 ? _a : (win ? win.location.toString() : ''),
        });
    };
};
const stateChangePrevious = () => {
    const cache = {};
    return (params) => {
        const previous = cache[params.stateType] || null;
        cache[params.stateType] = params.current;
        return () => ({ previous });
    };
};

var providers = /*#__PURE__*/Object.freeze({
	__proto__: null,
	clientClockProvider: clientClockProvider,
	serviceWorkerStateProvider: serviceWorkerStateProvider,
	createSessionProvider: createSessionProvider,
	typeProvider: typeProvider,
	referrerProvider: referrerProvider,
	sourceUriProvider: sourceUriProvider,
	stateChangePrevious: stateChangePrevious
});

const sessionProvider = createSessionProvider();
const sessionStarted = createEvent(StartedSessionV1_1, typeProvider(StartedSessionV1_5.OrgOpenstaxEcStartedSessionV1), clientClockProvider, referrerProvider(), sourceUriProvider(), sessionProvider, serviceWorkerStateProvider());
const accessedStudyguide = createEvent(AccessedStudyguideV1_1, typeProvider(AccessedStudyguideV1_4.OrgOpenstaxEcAccessedStudyguideV1), clientClockProvider, sourceUriProvider(), sessionProvider);
const createdHighlight = createEvent(CreatedHighlightV1_1, typeProvider(CreatedHighlightV1_4.OrgOpenstaxEcCreatedHighlightV1), clientClockProvider, sourceUriProvider(), sessionProvider);
const nudged = createEvent(NudgedV1_1, typeProvider(NudgedV1_4.OrgOpenstaxEcNudgedV1), clientClockProvider, sourceUriProvider(), sessionProvider);
const interacted = createEvent(InteractedElementV1_1, typeProvider(InteractedElementV1_4.OrgOpenstaxEcInteractedElementV1), clientClockProvider, sourceUriProvider(), sessionProvider);
const stateChange = createEvent(ChangedStateV1_1, typeProvider(ChangedStateV1_4.OrgOpenstaxEcChangedStateV1), stateChangePrevious(), clientClockProvider, sourceUriProvider(), sessionProvider);

var events = /*#__PURE__*/Object.freeze({
	__proto__: null,
	createEvent: createEvent,
	sessionProvider: sessionProvider,
	sessionStarted: sessionStarted,
	accessedStudyguide: accessedStudyguide,
	createdHighlight: createdHighlight,
	nudged: nudged,
	interacted: interacted,
	stateChange: stateChange
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

var Event = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventToJSON = exports.EventFromJSONTyped = exports.EventFromJSON = void 0;
function EventFromJSON(json) {
    return EventFromJSONTyped(json);
}
exports.EventFromJSON = EventFromJSON;
function EventFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'data': json['data'],
    };
}
exports.EventFromJSONTyped = EventFromJSONTyped;
function EventToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data,
    };
}
exports.EventToJSON = EventToJSON;
});

unwrapExports(Event);
var Event_1 = Event.EventToJSON;
var Event_2 = Event.EventFromJSONTyped;
var Event_3 = Event.EventFromJSON;

var Events = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventsToJSON = exports.EventsFromJSONTyped = exports.EventsFromJSON = void 0;


function EventsFromJSON(json) {
    return EventsFromJSONTyped(json);
}
exports.EventsFromJSON = EventsFromJSON;
function EventsFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'events': !runtime.exists(json, 'events') ? undefined : (json['events'].map(models.EventFromJSON)),
    };
}
exports.EventsFromJSONTyped = EventsFromJSONTyped;
function EventsToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'events': value.events === undefined ? undefined : (value.events.map(models.EventToJSON)),
    };
}
exports.EventsToJSON = EventsToJSON;
});

unwrapExports(Events);
var Events_1 = Events.EventsToJSON;
var Events_2 = Events.EventsFromJSONTyped;
var Events_3 = Events.EventsFromJSON;

var InfoData = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InfoDataToJSON = exports.InfoDataFromJSONTyped = exports.InfoDataFromJSON = void 0;

function InfoDataFromJSON(json) {
    return InfoDataFromJSONTyped(json);
}
exports.InfoDataFromJSON = InfoDataFromJSON;
function InfoDataFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'kafkaTopics': !runtime.exists(json, 'kafka_topics') ? undefined : json['kafka_topics'],
        'schemaRegistrySubjects': !runtime.exists(json, 'schema_registry_subjects') ? undefined : json['schema_registry_subjects'],
    };
}
exports.InfoDataFromJSONTyped = InfoDataFromJSONTyped;
function InfoDataToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'kafka_topics': value.kafkaTopics,
        'schema_registry_subjects': value.schemaRegistrySubjects,
    };
}
exports.InfoDataToJSON = InfoDataToJSON;
});

unwrapExports(InfoData);
var InfoData_1 = InfoData.InfoDataToJSON;
var InfoData_2 = InfoData.InfoDataFromJSONTyped;
var InfoData_3 = InfoData.InfoDataFromJSON;

var InfoResults = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InfoResultsToJSON = exports.InfoResultsFromJSONTyped = exports.InfoResultsFromJSON = void 0;


function InfoResultsFromJSON(json) {
    return InfoResultsFromJSONTyped(json);
}
exports.InfoResultsFromJSON = InfoResultsFromJSON;
function InfoResultsFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'overallTookMs': !runtime.exists(json, 'overall_took_ms') ? undefined : json['overall_took_ms'],
        'envName': !runtime.exists(json, 'env_name') ? undefined : json['env_name'],
        'accountsEnvName': !runtime.exists(json, 'accounts_env_name') ? undefined : json['accounts_env_name'],
        'amiId': !runtime.exists(json, 'ami_id') ? undefined : json['ami_id'],
        'gitSha': !runtime.exists(json, 'git_sha') ? undefined : json['git_sha'],
        'data': !runtime.exists(json, 'data') ? undefined : models.InfoDataFromJSON(json['data']),
    };
}
exports.InfoResultsFromJSONTyped = InfoResultsFromJSONTyped;
function InfoResultsToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': models.InfoDataToJSON(value.data),
    };
}
exports.InfoResultsToJSON = InfoResultsToJSON;
});

unwrapExports(InfoResults);
var InfoResults_1 = InfoResults.InfoResultsToJSON;
var InfoResults_2 = InfoResults.InfoResultsFromJSONTyped;
var InfoResults_3 = InfoResults.InfoResultsFromJSON;

var ModelError = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelErrorToJSON = exports.ModelErrorFromJSONTyped = exports.ModelErrorFromJSON = void 0;

function ModelErrorFromJSON(json) {
    return ModelErrorFromJSONTyped(json);
}
exports.ModelErrorFromJSON = ModelErrorFromJSON;
function ModelErrorFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'statusCode': !runtime.exists(json, 'status_code') ? undefined : json['status_code'],
        'messages': !runtime.exists(json, 'messages') ? undefined : json['messages'],
    };
}
exports.ModelErrorFromJSONTyped = ModelErrorFromJSONTyped;
function ModelErrorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'status_code': value.statusCode,
        'messages': value.messages,
    };
}
exports.ModelErrorToJSON = ModelErrorToJSON;
});

unwrapExports(ModelError);
var ModelError_1 = ModelError.ModelErrorToJSON;
var ModelError_2 = ModelError.ModelErrorFromJSONTyped;
var ModelError_3 = ModelError.ModelErrorFromJSON;

var models = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(AccessedStudyguideV1, exports);
__exportStar(ChangedStateV1, exports);
__exportStar(CreatedHighlightV1, exports);
__exportStar(Event, exports);
__exportStar(Events, exports);
__exportStar(InfoData, exports);
__exportStar(InfoResults, exports);
__exportStar(InteractedElementV1, exports);
__exportStar(ModelError, exports);
__exportStar(NudgedV1, exports);
__exportStar(StartedSessionV1, exports);
});

unwrapExports(models);

var EventsApi_1 = createCommonjsModule(function (module, exports) {
/* tslint:disable */
/* eslint-disable */
/**
 * OpenStax Event Capture API
 * The Event Capture API for OpenStax.  Requests to this API should include `application/json` in the `Accept` header.  The desired API version is specified in the request URL, e.g. `[domain]/api/v0`. While the API does support a default version, that version will change over time and therefore should not be used in production code!
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventsApi = void 0;


/**
 *
 */
class EventsApi extends runtime.BaseAPI {
    /**
     * Capture one or more events
     * Captures events
     */
    addEventsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.payload === null || requestParameters.payload === undefined) {
                throw new runtime.RequiredError('payload', 'Required parameter requestParameters.payload was null or undefined when calling addEvents.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/events`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models.EventsToJSON(requestParameters.payload),
            });
            return new runtime.VoidApiResponse(response);
        });
    }
    /**
     * Capture one or more events
     * Captures events
     */
    addEvents(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.addEventsRaw(requestParameters);
        });
    }
}
exports.EventsApi = EventsApi;
});

unwrapExports(EventsApi_1);
var EventsApi_2 = EventsApi_1.EventsApi;

const fetchApi = (input, init = {}) => fetch(input, Object.assign(Object.assign({}, init), { keepalive: true, credentials: 'include' }));
const makeClientContainer = () => {
    const container = {
        client: undefined,
        setConfig: (config) => {
            container.client = new EventsApi_2(new runtime_9(Object.assign({ fetchApi }, (config ? config : {}))));
        }
    };
    return container;
};

const jobRunner = (clientContainer, job, options) => {
    let timer;
    const sendingEnabled = () => options.sendingEnabled instanceof Function
        ? options.sendingEnabled()
        : options.sendingEnabled;
    const clearTimer = () => {
        clearInterval(timer);
        timer = undefined;
    };
    const run = () => {
        clearTimer();
        if (clientContainer.client && sendingEnabled()) {
            job(clientContainer.client).catch(() => runLater(options.retryInterval));
        }
        else {
            runLater();
        }
    };
    const runLater = (interval = options.batchInterval) => {
        if (timer) {
            return;
        }
        timer = setTimeout(run, interval);
    };
    return {
        run,
        runLater
    };
};

const makeFlush = (queue, clientContainer, options) => jobRunner(clientContainer, client => {
    const records = queue.splice(0);
    if (records.length === 0) {
        return Promise.resolve();
    }
    const events = records.map(record => ({ data: record() }));
    const handleError = (e) => {
        if (e instanceof TypeError) {
            queue.unshift(...records);
            throw e;
        }
        else {
            options.reportError(e);
        }
    };
    return client.addEvents({ payload: { events } })
        .catch(handleError);
}, options);
const defaultOptions = {
    sendingEnabled: true,
    reportError: () => null,
    batchInterval: 60000,
    retryInterval: 60000,
    initialized: true,
    document: typeof document === 'undefined' ? undefined : document,
};
const createCaptureContext = (passedOptions = {}) => {
    const _a = Object.assign(Object.assign({}, defaultOptions), passedOptions), { document, clientConfig } = _a, options = __rest(_a, ["document", "clientConfig"]);
    const clientContainer = makeClientContainer();
    if (options.initialized) {
        clientContainer.setConfig(clientConfig);
    }
    const queue = [];
    const flush = makeFlush(queue, clientContainer, options);
    const capture = (event) => {
        queue.push(event);
        flush.runLater();
    };
    if (document) {
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                flush.run();
            }
        });
    }
    return {
        capture,
        configure: clientContainer.setConfig,
        queue: queue
    };
};

exports.createCaptureContext = createCaptureContext;
exports.events = events;
exports.providers = providers;
